#this is a collection of ten functions, corresponding to tori. They should all accept order, a twisted weight from the weight twister function, the correct lookup tables, a column index, and the decomposition matrix

tone := proc(a,b,c,column,order,DM::Matrix,t1_lt)

#manage the parameter sets via lookuptables here
	local a1:
	local b1:
	local c1:

if a mod (order-1) = 0 then 
   a1 := 0:
else 
   a1 := t1_lt[a mod (order-1)]:
end if;

if b mod (order-1)= 0 then
    b1 := 0:
else 
    b1 := t1_lt[b mod (order-1)]:
end if;

if c mod (order-1) = 0  then 
   c1 := 0:
else 
   c1 := t1_lt[c mod (order-1)]:     #this is the simplest case of parameter management in the entire complex
end if;

#Begin if/else tree for D-L chars

if a1=0 then
   chi11(1,column,DM);
   chi12(3,column,DM); 
   chi13(1,column,DM);
   chi14(2,column,DM);
   chi16(3,column,DM);
   chi17(3,column,DM);
   chi18(3,column,DM);
   chi19(2,column,DM);
   chi110(1,column,DM);
   chi112(1,column,DM);      #this is the result of (0,0,0), which for T_1 is equivalent to a=0. 

elif b1=0 then
     chi61(1,a1,order,column,DM);
     chi62(2,a1,order,column,DM);
     chi63(1,a1,order,column,DM);
     chi64(1,a1,order,column,DM);
     chi66(1,a1,order,column,DM);      # case (a,0,0)
    
elif c1=0 then
    if a1=b1 then
     chi11_1(1,a1,order,column,DM);
     chi11_2(1,a1,order,column,DM);
     chi113(1,a1,order,column,DM);
     chi114(1,a1,order,column,DM);  # case (a,a,0)

     else 
          chi171(1,a1,b1,order,column,DM);
	  chi172(1,a1,b1,order,column,DM);  # case (a,b,0)

	  end if; 

elif a1=c1 then
     chi81(1,a1,order,column,DM);
     chi82(2,a1,order,column,DM);
     chi83(1,a1,order,column,DM); # case (a,a,a)
    
elif b1=c1 then
     chi161(1,a1,b1,order,column,DM);
     chi162(1,a1,b1,order,column,DM);  # case (a,b,b)

elif a1=b1 then
     chi161(1,a1,c1,order,column,DM);
     chi162(1,a1,c1,order,column,DM);  # case (a,a,b)

else 
     chi251(1,a1,b1,c1,order,column,DM);     #case (a,b,c)


#else some kind of error message throw catch?

end if;

end proc;

#############################################################################################################

#############################################################################################################

ttwo := proc(a,b,c,column,order,DM::Matrix, t1_lt, t2_lt)

local a1:
local b1:
local c1:

if a mod (order-1)=0 then
   a1 := 0:
else
   a1 := t1_lt[a mod (order-1)];
end if;

if b1 mod (order-1)=0 then
   b1 := 0:
else
   b1 := t1_lt[b mod (order-1)];
end if;

if c1 mod (order+1 )=0 then
   c1 := 0:
else
   c1 := t2_lt[c mod (order+1)];
end if;

#Here, the parameters have been permuted, which makes the if-else tree more complex. 


if a1=0 then
    if b1=0 then
   	 if c1=0 then
  	 #case 000
       	       chi11(-1,column,DM);
	       chi12(-1,column,DM);
	       chi13(1,column,DM);
	       chi14(-2,column,DM);
	       chi16(1,column,DM);
	       chi17(-1,column,DM);
	       chi18(1,column,DM);
	       chi19(2,column,DM);
	       chi110(-1,column,DM);
	       chi112(1,column,DM);
         else #case 00c
	      chi71(1,c1,order,column,DM);
	      chi72(2,c1,order,column,DM);
	      chi73(1,c1,order,column,DM);
	      chi74(1,c1,order,column,DM);
	      chi76(1,c1,order,column,DM);
      end if;
   elif c1=0 then
   	#case 0b0
	      chi61(-1,b1,order,column,DM);
	      chi63(-1,b1,order,column,DM);
	      chi64(1,b1,order,column,DM);
	      chi66(1,b1,order,column,DM);
     else #case 0bc
     	  chi201(1,b1,c1,order,column,DM);
	  chi202(1,b1,c1,order,column,DM);
   end if;
else #a1!=0 
     if b1=0 then 
     	if c1=0 then
	   #case a00
	   	 chi61(-1,a1,order,column,DM);
		 chi63(-1,a1,order,column,DM);
                 chi64(1,a1,order,column,DM);
                 chi66(1,a1,order,column,DM);
	 else 
	     #case a0c
	     	   chi201(1,a1,c1,order,column,DM);
                   chi202(1,a1,c1,order,column,DM);
        end if;
      else
       if c1=0 then
       	   if a1=b1 then
      	       #case aa0
	       	     chi11_1(-1,a1,order,column,DM);
		     chi11_2(1,a1,order,column,DM);
		     chi113(-1,a1,order,column,DM);
		     chi114(1,a1,order,column,DM);
	  else
	       	     chi171(-1,a1,b1,order,column,DM);
		     chi172(1,a1,b1,order,column,DM);
   	 end if;
else #none are zero
     if a1=b1 then
	   chi181(1,a1,c1,order,column,DM);
	   chi182(1,a1,c1,order,column,DM);
     else 
	  chi261(1,a1,b1,c1,order,column,DM);
     end if;
end if;
end if;
end if;


end proc;

#############################################################################################################

#############################################################################################################

tthree := proc(a,b,column,order,DM::Matrix,t1_lt,t2_lt,r1_lt)

#parameter management; a is the result of a+qb and is reduced mod q^2-1, b is reduced mod q-1
local a1:  #case a ain't congruent to anything
local a2: #case a congruent to q-1
local a3: #case a congruent to q+1 
local b1:

if b mod (order - 1) = 0 then
   b1 := 0;
else
   b1 := t1_lt[b mod (order-1)];
end if;

if a mod (order ^ 2 - 1) = 0 then
   a1:=0;
   a2:=0;
   a3:=0;
elif a mod (order+1)=0 then
   a3 := t1_lt[a mod (order ^ 2 - 1) / (order + 1)];
   a2:=0;
   a1:=0;
elif a mod (order - 1)=0 then
   a2 := t2_lt[a mod (order ^ 2 - 1) / (order - 1)];
   a1:=0;
   a3:=0;
else
   a1 := r1_lt[a mod (order ^ 2 - 1)];
   a2:=0;
   a3:=0;
end if;   # the various congruence if/elif

#if-else tree for character calls. Note that the same if-else from the parameter management must be a sub-tree
#question: since the cases are uniquely determined in the cases above, should we use that, or rebuild the tree as was done in tseven and tten? Good practice? 



end proc;

#############################################################################################################

#############################################################################################################

tfour := proc(a,b,c,column,order,DM::Matrix,t1_lt,t2_lt)

#parameter management

local a1:
local b1:
local c1:

if a mod (order-1)=0 then
   a1 := 0:
else
   a1 := t1_lt[a mod (order-1)];
end if;

if b1 mod (order-1)=0 then
   b1 := 0:
else
   b1 := t2_lt[b mod (order+1)];
end if;

if c1 mod (order+1 )=0 then
   c1 := 0:
else
   c1 := t2_lt[c mod (order+1)];
end if;

#i else tree for character calls


end proc;

#############################################################################################################

#############################################################################################################

tfive := proc(a,b,column,order,DM::Matrix)

#parameter management; a is the result of a+-qb and is reduced mod q^2-1, b is reduced mod q+1
local a1: #case a ain't congruent to anything
local a2: #case a congruent to q-1
local a3: #case a congruent to q+1 
local b1:

if b mod (order + 1) = 0 then
   b1 := 0;
else
   b1:= t2_lt[b mod (order-1)];
end if;

if a mod (order ^ 2 - 1) = 0 then
    a1:=0;
    a2:=0;
    a3:=0;
elif a mod (order+1)=0 then
   a3 := t1_lt[a mod (order ^ 2 - 1) / (order + 1)];
   a2:=0;
   a1:=0;
elif a mod (order - 1)=0 then
   a2 := t2_lt[a mod (order ^ 2 - 1) / (order - 1)];
   a1:=0;
   a3:=0;
else
   a1 := r1_lt[a mod (order ^ 2 - 1)];
   a2:=0;
   a3:=0;
end if;   # the various congruence if/elif

#if else tree for character calls

end proc;

#############################################################################################################

#############################################################################################################

tsix := proc(a,b,column,order,DM::Matrix,r2_lt,t1_lt)

#parameter management made easy by virtue of few cases. a is the result of a+-qb and is reduced mod q^2+1, b is reduced mod q-1
local a1:
local b1:

if a mod (order^2 +1)=0 then 
   a1:=0;
else
   a1:=r2_lt[a mod (order ^ 2 + 1)];
end if;

if b mod (order - 1)=0 then 
   b1:=0;
else
   b1:= t1_lt[b mod (order -1)];
end if;


#if else tree for character calls

end proc;

#############################################################################################################

#############################################################################################################

tseven := proc(a,column,order,DM::Matrix,s1_lt,t1_lt)
#parameter management

local a1:   #a is congruent to a zero divisor
local a2:   #a is not congruent to anything

if a mod (order ^ 3 - 1)= 0 then
   chi11(1,column,DM);
   chi13(1,column,DM);
   chi14(-1,column,DM);
   chi19(-1,column,DM);
   chi110(1,column,DM);
   chi112(1,column,DM);
elif a mod (order ^ 2 + order + 1)=0 then
    a1 := t1_lt[a mod (order ^ 3 - 1)  / (order ^ 2 + order + 1)];
    chi81(1,a1, order,column,DM);
    chi82(-1,a1,order,column,DM);
    chi83(1,a1,order,column,DM);
else
    a2 := s1_lt[a mod	(order ^ 3 - 1)];
    chi311(1,a2,order,column,DM);
end if;

end proc;

#############################################################################################################

#############################################################################################################

teight := proc(a,b,c,column,order,DM::Matrix,t2_lt)
        local a1:
        local b1:
        local c1:

if a mod (order+1) = 0 then
    a1 := 0:
else
    a1 := t2_lt[a mod (order+1)]:
end if;

if b mod (order+1)= 0 then
    b1 := 0:
else
    b1 := t2_lt[b mod (order+1)]:
end if;

if c mod (order+1) = 0 then
   c1 := 0:
else
   c1 := t2_lt[c mod (order+1)]:  
end if;

#Begin if/else tree for D-L chars
if a1=0 then
   chi11(-1,column,DM);
   chi12(1,column,DM);
   chi13(3,column,DM);
   chi15(2,column,DM);
   chi16(-3,column,DM);
   chi17(3,column,DM);
   chi18(-1,column,DM);
   chi110(-3,column,DM);
   chi111(-2,column,DM);
   chi112(1,column,DM);      #this is the result of (0,0,0), which for T_8 is equivalent to a=0.

elif b1=0 then
     chi71(1,a1,order,column,DM);
     chi73(-1,a1,order,column,DM);
     chi74(-1,a1,order,column,DM);
     chi75(-2,a1,order,column,DM);
     chi76(1,a1,order,column,DM);      # case (a,0,0)

elif c1=0 then
    if a1=b1 then
     chi131(1,a1,order,column,DM);
     chi132(-1,a1,order,column,DM);
     chi133(-1,a1,order,column,DM);
     chi134(1,a1,order,column,DM);  # case (a,a,0)

     else
          chi231(-1,a1,b1,order,column,DM);
          chi232(1,a1,b1,order,column,DM);  # case (a,b,0)

          end if; 

elif a1=c1 then
     chi91(-1,a1,order,column,DM);
     chi92(-2,a1,order,column,DM);
     chi93(1,a1,order,column,DM); # case (a,a,a)

elif b1=c1 then
     chi221(-1,a1,b1,order,column,DM);
     chi222(1,a1,b1,order,column,DM);  # case (a,b,b)

elif a1=b1 then
     chi221(-1,a1,c1,order,column,DM);
     chi222(1,a1,c1,order,column,DM);  # case (a,a,b)

else
     chi231(1,a1,b1,c1,order,column,DM);     #case (a,b,c)


end if;


end proc;

#############################################################################################################

#############################################################################################################

tnine := proc(a,b,column,order,DM::Matrix,r2_lt,t2_lt)

#parameter management made easy by virtue of few cases. a is the result of a+-qb and is reduced mod q^2+1, b is reduced mod q+1
local a1:
local b1:

if a mod (order^2 +1)=0 then 
    a1 := 0;
else
    a1 := r2_lt[a mod (order ^ 2 + 1)];
end if;

if b mod (order + 1)=0 then 
    b1 := 0;
else
    b1:= t2_lt[b mod (order +1)];
end if;


#if else tree for character calls

end proc;

#############################################################################################################

#############################################################################################################

tten := proc(a,column,order,DM::Matrix,s2_lt,t2_lt)
#parameter management
local a1:
local a2:

if a mod (order ^ 3 + 1) = 0 then
   chi11(-1,column,DM);
   chi12(1,column,DM);
   chi15(-1,column,DM);
   chi18(-1,column,DM);
   chi111(1,column,DM);
   chi112(1,column,DM);
elif a mod (order ^ 2 - order + 1) = 0 then 
     a1 := t2_lt[a mod (order ^ 3 + 1)  / (order ^ 2 - order + 1)]; 
     chi91(-1,a1, order,column,DM);
     chi92(1,a1,order,column,DM);
     chi93(1,a1,order,column,DM);
else
     a2 := s2_lt[a mod (order ^ 3 + 1)];
     chi341(1,a2,order,column,DM);
end if; #cong 0 mod zero diviser

end proc;

