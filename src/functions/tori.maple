#this is a collection of ten functions, corresponding to tori. They should all accept order, and a twisted weight from the weight twister function

tone := proc(a,b,c,column,order,DM::Matrix,t1_lt)

#manage the parameter sets via lookuptables here

local a1 := t1_lt[a]:
local b1 := t1_lt[b]:
local c1 := t1_lt[c];     #this is the simplest case of parameter management in the entire complex

if a1=0 then
   chi11(1,column,DM);
   chi12(3,column,DM); 
   chi13(1,column,DM);
   chi14(2,column,DM);
   chi16(3,column,DM);
   chi17(3,column,DM);
   chi18(3,column,DM);
   chi19(2,column,DM);
   chi110(1,column,DM);
   chi112(1,column,DM);

elif b1=0 then
     chi61();
     #etc
elif c1=0 then
    if a1=b1 then
     chi111();
     #andc

     else 
          chi171(a1,b1,);
    	  #andc

elif a1=c1 then
     chi81(a1,);
     #andc
elif b1=c1 then
     chi161(a1,b1,);
     #andc
else 
     chi251(a1,b1,c1,);     


#else some kind of error message throw catch?
end if;

end proc;

ttwo := proc(a,b,c,column,order,DM::Matrix, t1_lt, t2_lt)

local a1 := t1_lt[a];
local b1 := t1_lt[b];
local c1 := t2_lt[c];

#Here, since a,b,c have been possibly permuted, we may make use of sets to manage cases in the if-else tree


end proc;

tthree := proc(a,b,column,order,DM::Matrix)


end proc;

tfour := proc(a,b,c,column,order,DM::Matrix)


end proc;

tfive := proc(a,b,column,order,DM::Matrix)

end proc;

tsix := proc(a,b,column,order,DM::Matrix)

end proc;

tseven := proc(a,column,order,DM::Matrix)

end proc;

teight := proc(a,b,c,column,order,DM::Matrix)

end proc;

tnine := proc(a,b,column,order,DM::Matrix)

end proc;

tten := proc(a,column,order,DM::Matrix)

end proc;

